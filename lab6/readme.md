### 用户态环境与系统调用说明文档 (User-mode & System Call Deep Dive)

本章详细介绍了本项目如何构建用户态运行环境，以及如何通过 RISC-V 的 `ecall` 机制实现跨特权级的系统服务请求。

#### 1. 全链路流程图解

从用户代码调用到内核返回的完整生命周期：
用户程序调用库函数 -> 汇编陷阱进入内核 -> 系统调用分发 -> 内核函数执行 -> 返回用户态。
---

#### 2. 用户态基石 (User-land Implementation)

用户程序并不能直接运行在裸机上，它需要 C 运行时（CRT）的支持。

* **程序入口点 (`crt0.S`)**：
这是用户可执行文件的“真正起始地址”。
* **职责**：它不是普通的 C 函数，而是汇编代码。它负责调用用户编写的 `main` 函数。
* **关键点**：当 `main` 执行完毕返回时，`crt0.S` 会强制执行 `exit` 系统调用。这防止了 CPU 继续执行 `main` 之后的随机指令。


* **基础库封装 (`ulib.c`)**：
为了提高开发效率，我们提供了用户态库函数。
* **puts**：内部调用 `write(1, s, strlen(s))`。
* **strlen**：计算字符串长度。
* 这些函数隐藏了系统调用的原始复杂性（如手动填入文件描述符）。


* **初始进程 (`init.c`)**：
系统的第一个用户进程。它演示了最简单的 I/O 操作：通过 `write` 向控制台打印欢迎信息。

---

#### 3. 跨越特权级的桥梁：系统调用

系统调用本质上是一种“受控的异常（Exception）”。

* **汇编跳板 (`usys.S`)**：
这是用户态与内核态的边界。它使用汇编宏批量生成接口：
```assembly
# 宏定义：将编号放入 a7 寄存器并触发中断
.macro SYSCALL name, num
    li a7, \num
    ecall
    ret
.endm

SYSCALL fork, 1
SYSCALL write, 9
...

```


当用户执行 `write()` 时，实际上是执行了这段汇编。`ecall` 指令会瞬间将 CPU 从 **U-mode** 切换到 **S-mode**。
* **内核分发器 (`syscall.c`)**：
当内核捕获到 `ecall` 异常后，会跳转到 `syscall()` 函数：
* **识别请求**：从用户陷阱帧（trapframe）的 `a7` 寄存器读取调用号。
* **执行处理**：在 `syscall_table` 数组中查找对应的内核函数（如 `sys_write`）。
* **处理参数**：内核不能直接访问用户指针（因为可能非法），必须使用 `argint`（获取整数）、`argaddr`（获取地址）和 `argstr`（安全拷贝字符串）进行边界检查。



---

#### 4. 已实现的内核处理逻辑

| 内核函数 | 对应调用 | 所属模块 | 详细说明 |
| --- | --- | --- | --- |
| `sys_fork` | `fork` | `sysproc.c` | 复制当前进程，利用 `fork_process()` 创建子进程。 |
| `sys_exit` | `exit` | `sysproc.c` | 接收退出状态，清理资源并将进程设为 `ZOMBIE`。 |
| `sys_write` | `write` | `sysfile.c` | 检查 FD 权限，通过 `copyin` 从用户空间提取数据，最终写向 UART 或文件。 |
| `sys_sbrk` | `sbrk` | `sysproc.c` | 动态调整进程的 `p->sz`，即分配或释放物理页。 |
| `sys_exec` | `exec` | `sysexec.c` | 将新的 ELF 镜像加载到内存，重置页表和堆栈。 |

---

#### 5. 核心安全机制：数据交换

由于内核与用户程序位于不同的页表（地址空间）中，内核无法通过简单的赋值来交换数据，必须使用专门的函数：

1. **`copyin(pgtbl, dest, src, len)`**：从用户虚拟地址 `src` 安全地拷贝数据到内核地址 `dest`。
2. **`copyout(pgtbl, dest, src, len)`**：将内核结果写回用户缓冲区。
3. **`copyinstr`**：专门处理以 `\0` 结尾的字符串，附带长度限制，防止恶意用户提供超长字符串导致内核缓冲区溢出。
