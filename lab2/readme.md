# `printf`实现文档

## 1. 打印系统架构

系统的打印功能采用了分层设计，确保了硬件无关性与多核安全性。

| 层级 | 模块 | 主要职责 |
| --- | --- | --- |
| **格式化层** | `print.c` | 解析格式化字符串（如 `%d`, `%x`），将数据转为字符流 |
| **抽象层** | `console.c` | 承上启下，提供统一的控制台输出接口 `console_putc` |
| **驱动层** | `uart.c` | 直接操作 16550a UART 寄存器，实现硬件字节传输 |

---

## 2. 核心模块详解

### 2.1 底层驱动：UART (`uart.c`)

* **寄存器操作**：通过宏 `WriteReg` 和 `ReadReg` 直接读写 UART 硬件寄存器（如 `THR` 发送保持寄存器、`LSR` 状态寄存器）。
* **同步发送**：`uart_putc_sync` 函数会轮询 `LSR_TX_IDLE` 标志位，确保硬件准备好接收下一个字符后再写入 `THR`。
* **初始化**：`uart_init` 负责设置波特率（38.4K）、数据位长度（8-bit）及启用 FIFO 队列。

### 2.2 格式化输出：`printf` (`print.c`)

* **变长参数处理**：利用 `stdarg.h` 的 `va_list` 机制解析 `printf` 传入的不定长参数。
* **支持的格式说明符**：
* `%s`: 字符串输出。
* `%d`: 有符号十进制（处理了负数符号及 `INT_MIN` 边界情况）。
* `%x` / `%p`: 十六进制及指针地址输出。
* `%c`: 单个字符。


* **多核同步**：引入了 `print_lk` 自旋锁。在打印期间持有锁，防止多个 CPU 核心的输出信息在串口交织导致乱码。

### 2.3 ANSI 终端增强功能

系统通过发送 **ANSI 转义序列** 实现了简单的图形界面模拟：

* **清屏** (`clear_screen`)：发送 `\x1b[2J` 清除屏幕并重置光标。
* **光标定位** (`goto_xy`)：通过 `\x1b[row;colH` 将光标移动到指定行列。
* **颜色控制** (`set_color`)：支持设置前景（文字）和背景颜色。

---

## 3. 健壮性设计

### 3.1 Panic 机制

当内核调用 `panic` 时：

1. 全局标志位 `panicked` 被置为 1。
2. **绕过锁机制**：为了防止死锁（例如在持有打印锁时触发异常），`panic` 路径会绕过自旋锁，直接调用底层 `uart_putc_sync` 输出错误信息。
3. 系统挂起：进入无限循环。

### 3.2 中断安全

在进行字符输出时，`uart_putc_sync` 会调用 `push_off()` 关闭当前核心的中断，确保打印过程不被中断处理程序打断，增强了操作的原子性。

---

## 4. 启动演示案例 (`start.c`)

在引导过程中，主核 (Hart 0) 会利用这些功能展示内核能力：

```c
clear_screen();
set_color(2, -1); // 绿色文字
printf("=== OS Lab: Kernel printf & ANSI Demo ===\n");
reset_color();
printf("cpuid=%d, hex=0x%x\n", mycpuid(), 0xABC); // 验证格式化输出

```
